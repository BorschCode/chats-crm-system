name: Deploy to Raspberry Pi

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Docker image tag to deploy"
        required: true
        default: "latest"

jobs:
  deploy:
    name: Deploy to Raspberry Pi
    runs-on: [self-hosted, Linux, ARM64]
    environment: raspberry

    env:
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      IMAGE_TAG: ${{ github.event.inputs.image_tag }}

    steps:
      - name: Extract image tag
        id: image_tag
        run: |
          echo "tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Deploying image tag: ${IMAGE_TAG}"

      - name: Detect platform architecture
        id: arch
        run: |
          ARCH=$(uname -m)
          echo "Detected architecture: $ARCH"

          if [ "$ARCH" = "aarch64" ]; then
            PLATFORM="linux/arm64"
          elif [ "$ARCH" = "armv7l" ] || [ "$ARCH" = "armv6l" ]; then
            PLATFORM="linux/arm/v7"
          elif [ "$ARCH" = "x86_64" ]; then
            PLATFORM="linux/amd64"
          else
            echo "Unsupported architecture: $ARCH"
            exit 1
          fi

          echo "platform=${PLATFORM}" >> $GITHUB_OUTPUT
          echo "Using Docker platform: ${PLATFORM}"

      - name: Clean workspace
        run: |
          find "${{ github.workspace }}" -mindepth 1 -maxdepth 1 ! -name ".git" -exec rm -rf {} +

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Free up memory before pull
        run: |
          echo "Freeing up memory..."
          docker system prune -af --volumes || true
          sync
          echo "Memory status:"
          free -h
          df -h

      - name: Pull image with platform specification
        run: |
          PLATFORM="${{ steps.arch.outputs.platform }}"
          IMAGE="${DOCKER_USERNAME}/chats-crm-system:${IMAGE_TAG}"

          echo "Pulling image: ${IMAGE}"
          echo "Platform: ${PLATFORM}"

          for i in {1..3}; do
            echo "Pull attempt $i of 3..."
            if docker pull --platform "${PLATFORM}" "${IMAGE}"; then
              echo "Image pulled successfully!"
              exit 0
            fi
            echo "Pull failed, retrying..."
            docker system prune -af || true
            sync
            sleep 10
          done

          echo "Failed to pull image after 3 attempts"
          exit 1

      - name: Stop and remove old container
        run: |
          docker compose -f compose.raspberry.yml down --remove-orphans || true
          docker ps -aq --filter "name=chats-crm" | xargs -r docker rm -f || true
          docker image prune -af || true
          echo "Cleanup completed"

      - name: Create .env file
        run: |
          cat > .env << 'EOF'
          APP_NAME="${{ vars.APP_NAME }}"
          APP_ENV=production
          APP_KEY=${{ secrets.APP_KEY }}
          APP_DEBUG=${{ vars.APP_DEBUG }}
          APP_URL=${{ vars.APP_URL }}
          APP_PORT=${{ vars.APP_PORT }}

          APP_LOCALE=en
          APP_FALLBACK_LOCALE=en

          LOG_CHANNEL=stack
          LOG_STACK=daily
          LOG_LEVEL=warning

          DB_CONNECTION=mysql
          DB_HOST=${{ vars.DB_HOST }}
          DB_PORT=3306
          DB_DATABASE=${{ vars.DB_DATABASE }}
          DB_USERNAME=${{ vars.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}

          SESSION_DRIVER=database
          SESSION_LIFETIME=120

          CACHE_STORE=database
          QUEUE_CONNECTION=database

          MAIL_MAILER=${{ vars.MAIL_MAILER }}
          MAIL_HOST=${{ vars.MAIL_HOST }}
          MAIL_PORT=${{ vars.MAIL_PORT }}
          MAIL_USERNAME=${{ vars.MAIL_USERNAME }}
          MAIL_PASSWORD=${{ secrets.MAIL_PASSWORD }}
          MAIL_FROM_ADDRESS=${{ vars.MAIL_FROM_ADDRESS }}
          MAIL_FROM_NAME="${{ vars.APP_NAME }}"

          TELEGRAM_TOKEN=${{ secrets.TELEGRAM_TOKEN }}
          TELEGRAM_BOT_USERNAME=${{ vars.TELEGRAM_BOT_USERNAME }}

          WHATSAPP_ACCESS_TOKEN=${{ secrets.WHATSAPP_ACCESS_TOKEN }}
          WHATSAPP_PHONE_NUMBER_ID=${{ vars.WHATSAPP_PHONE_NUMBER_ID }}
          WHATSAPP_WEBHOOK_VERIFY_TOKEN=${{ secrets.WHATSAPP_WEBHOOK_VERIFY_TOKEN }}
          WHATSAPP_API_VERSION=${{ vars.WHATSAPP_API_VERSION }}
          WHATSAPP_BUSINESS_ACCOUNT_ID=${{ vars.WHATSAPP_BUSINESS_ACCOUNT_ID }}
          EOF

      - name: Deploy with Docker Compose
        run: |
          echo "Using image: ${DOCKER_USERNAME}/chats-crm-system:${IMAGE_TAG}"
          docker compose -f compose.raspberry.yml up -d --no-deps
          echo "Container started"

      - name: Wait for container readiness
        run: |
          echo "Waiting for app container to be ready..."
          for i in {1..30}; do
            if docker compose -f compose.raspberry.yml exec -T app php -v >/dev/null 2>&1; then
              echo "App is ready"
              exit 0
            fi
            echo "Waiting ($i/30)..."
            sleep 2
          done
          echo "App failed to start"
          exit 1

      - name: Check environment and test connection
        run: |
          docker compose -f compose.raspberry.yml exec -T app php artisan config:clear
          echo "=== Environment Check ==="
          docker compose -f compose.raspberry.yml exec -T app printenv | grep -E "^DB_|^APP_" || echo "Failed to read environment"
          docker compose -f compose.raspberry.yml exec -T app php artisan env || echo "artisan env not available"
          echo "=== Testing Database Connection ==="
          docker compose -f compose.raspberry.yml exec -T app php artisan tinker --execute="try { DB::connection()->getPdo(); echo 'Database connected successfully!' . PHP_EOL; } catch (Exception \$e) { echo 'Connection failed: ' . \$e->getMessage() . PHP_EOL; echo 'Trace: ' . \$e->getTraceAsString() . PHP_EOL; throw \$e; }"
          echo "=== Clearing application cache ==="
          docker compose -f compose.raspberry.yml exec -T app php artisan cache:clear
          echo "=== Checking worker logs ==="
          docker compose -f compose.raspberry.yml exec -T app cat /var/www/html/storage/logs/worker.log | tail -50 || echo "No worker logs yet"
          echo "=== Checking Laravel application logs ==="
          docker compose -f compose.raspberry.yml exec -T app cat /var/www/html/storage/logs/laravel.log | tail -50 || echo "No Laravel logs yet"

      - name: Run database migrations
        run: |
          docker compose -f compose.raspberry.yml exec -T app php artisan migrate --force || {
            echo "=== Migration failed, checking logs ==="
            docker compose -f compose.raspberry.yml logs --tail=50 app
            exit 1
          }
          echo "Migrations completed"

      - name: Optimize application
        run: |
          docker compose -f compose.raspberry.yml exec -T app php artisan config:cache
          docker compose -f compose.raspberry.yml exec -T app php artisan route:cache
          docker compose -f compose.raspberry.yml exec -T app php artisan view:cache
          docker compose -f compose.raspberry.yml exec -T app php artisan optimize

      - name: Restart queue workers
        run: |
          docker compose -f compose.raspberry.yml exec -T app php artisan queue:restart

      - name: Cleanup old images
        run: docker image prune -af --filter "until=168h" || true

      - name: Deployment Status
        run: |
          echo "âœ… Successfully deployed ${IMAGE_TAG} to Raspberry Pi"
          docker compose -f compose.raspberry.yml ps
